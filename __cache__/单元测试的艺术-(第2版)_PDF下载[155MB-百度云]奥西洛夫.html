单元测试的艺术-(第2版) PDF下载 奥西洛夫 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711536035
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711536035
<p>书名:单元测试的艺术-(第2版)</p><p>作者:奥西洛夫</p><p>页数:228</p><p>定价:¥59.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2014-08-01</p><p>ISBN:9787115360359</p><p><h2>相关资料</h2></p>[<p>“不管你是单元测试和测试驱动开发的新手，还是已经有了丰富经验的人，都能在这本书里找到适合自己的内容。请准备好欣赏roy给你演唱的‘单元测试的艺术’。”<br/>
　　——robert c. martin，世界级软件开发大师，设计模式和敏捷开发先驱，敏捷联盟首任主席，被后辈程序员尊称为“bob大叔”<br/>
<br/>
　　“它是这一领域的经典之作，是学习单元测试的必读之书！”<br/>
　　——raphael faria，lg公司<br/>
<br/>
　　“本书集思想性与实用性于一体。”<br/>
　　——pradeep chellappan，微软公司<br/>
　　<br/>
　　“每当团队成员问我如何正确编写单元测试，我都会这样回答：看这本书！”<br/>
　　——alessandro campeis，vimar spa<br/>
<br/>
　　“学习单元测试的最佳图书，没有之一！”<br/>
　　——kaleb pederson，next it<br/></p>]<p><h2>本书特色</h2></p>[<p>
《单元测试的艺术(第2版)》是经典的单元测试学习指南，分四部分全面介绍了单元测试技术。**部分阐述单元测试基本概念，包括如何使用测试框架。第二部分讨论破除依赖的高级技术：模拟对象、存根和隔离框架，包括重构代码以使用这些技术的模式。第三部分介绍测试代码的组织方式、运行测试和重构测试结构的模式，以及编写测试的*佳实践。第四部分介绍如何在组织内实施变革和修改现有代码。
　　《单元测试的艺术(第2版)》适合所有语言的测试和开发人员，特别是测试主管和项目经理。
                                        </p>]<p><h2>内容简介</h2></p>[<p>基础概念+代码+具体分析
　　手把手教你学测试
　　解密神秘魔法：隔离框架
　　测试“不可测试”的代码</p>]<p><h2>作者简介</h2></p>[<p>Roy Osherove 世界著名单元测试专家，常年为世界各地的开发团队提供咨询和培训服务，并在各种大会上发表演讲，内容包括单元测试及测试驱动开发的艺术、团队领导力和敏捷开发实践。其个人技术博客osherove.com平均月独立访问量约50 000，上提供了各种技术视频及其他培训信息，另著有Notes to a Software Team Leader: Growing Self Organizing Teams。</p>]<p><h2>目录</h2></p>
    **部分　入门第1章　单元测试基础　1.1　逐步定义单元测试　1.1.1　编写优秀单元测试的重要性　1.1.2　我们都写过(某种)单元测试　1.2　优秀单元测试的特性　1.3　集成测试　1.4　什么是优秀的单元测试　1.5　一个简单的单元测试范例　1.6　测试驱动开发　1.7　成功进行tdd的三种核心技能　1.8　小结　第2章　**个单元测试　2.1　单元测试框架　2.1.1　单元测试框架提供什么　2.1.2　xunit框架　2.2　logan项目介绍　2.3　nunit初步　2.3.1　安装nunit　2.3.2　加载解决方案　2.3.3　在代码中使用nunit属性　2.4　编写**个测试　2.4.1　assert类　2.4.2　用nunit运行**个测试　2.4.3　添加正检验　2.4.4　从红到绿：测试成功　2.4.5　测试代码格式　2.5　使用参数重构测试　2.6　更多nunit属性　2.6.1　setup和teardown　2.6.2　检验预期的异常　2.6.3　忽略测试　2.6.4　nunit的方法语法　2.6.5　设置测试类别　2.7　测试系统状态的改变而非返回值　2.8　小结　第二部分　核心技术第3章　使用存根破除依赖　3.1　存根简介　3.2　发现logan中对文件系统的依赖　3.3　如何使测试loganalyzer变得容易　3.4　重构代码设计以提高可测试性　3.4.1　抽取接口使底层实现可替换　3.4.2　依赖注入：在被测试单元中注入一个伪实现　3.4.3　在构造函数层注入一个伪对象(构造函数注入)　3.4.4　用伪对象模拟异常　3.4.5　用属性get或set注入伪对象　3.4.6　在方法调用前注入伪对象　3.5　重构技术变种　3.6　克服封装问题　3.6.1　使用internal和[internalsvisibleto]　3.6.2　使用[conditional]属性　3.6.3　使用#if和#endif进行条件编译　3.7　小结　第4章　使用模拟对象进行交互测试　4.1　基于值的测试、基于状态的测试和交互测试　4.2　模拟对象和存根的区别　4.3　手工模拟对象的简单示例　4.4　同时使用模拟对象和存根　4.5　每个测试一个模拟对象　4.6　伪对象链：用存根生成模拟对象或其他存根　4.7　手工模拟对象和存根的问题　4.8　小结　第5章　隔离(模拟)框架　5.1　为什么要使用隔离框架　5.2　动态生成伪对象　5.2.1　在测试中使用nsubstitute　5.2.2　用动态伪对象替换手工伪对象　5.3　模拟值　5.4　测试事件相关的活动　5.4.1　测试事件监听者　5.4.2　测试事件是否触发　5.5　现有的.net隔离框架　5.6　隔离框架的优缺点　5.6.1　使用隔离框架时应避开的陷阱　5.6.2　测试代码不可读　5.6.3　验证错误的事情　5.6.4　一个测试多个模拟对象　5.6.5　过度指定测试　5.7　小结　第6章　深入了解隔离框架　6.1　受限框架及不受限框架　6.1.1　受限框架　6.1.2　不受限框架　6.1.3　基于探查器的不受限框架如何工作　6.2　优秀隔离框架的价值　6.3　支持适应未来和可用性的功能　6.3.1　递归伪对象　6.3.2　默认忽略参数　6.3.3　泛伪造　6.3.4　伪对象的非严格行为　6.3.5　非严格模拟对象　6.4　隔离框架设计反模式　6.4.1　概念混淆　6.4.2　录制和重放　6.4.3　粘性行为　6.4.4　复杂语法　6.5　小结　第三部分　测试代码第7章　测试层次和组织　7.1　运行自动化测试的自动化构建　7.1.1　构建脚本结构　7.1.2　触发构建和集成　7.2　基于速度和类型布局测试　7.2.1　分离集成测试和单元测试的人为因素　7.2.2　绿色安全区　7.3　确保测试是源代码管理的一部分　7.4　将测试类映射到被测试代码　7.4.1　将测试映射到项目　7.4.2　将测试映射到类　7.4.3　将测试映射到具体的工作单元入口　7.5　注入横切关注点　7.6　为应用程序构建测试api　7.6.1　使用测试类继承模式　7.6.2　创建测试工具类和方法　7.6.3　把你的api介绍给开发人员　7.7　小结　第8章　优秀单元测试的支柱　8.1　编写可靠的测试　8.1.1　决定何时删除或修改测试　8.1.2　避免测试中的逻辑　8.1.3　只测试一个关注点　8.1.4　把单元测试和集成测试分开　8.1.5　用代码审查确保代码覆盖率　8.2　编写可维护的测试　8.2.1　测试私有或受保护的方法　8.2.2　去除重复代码　8.2.3　以可维护的方式使用setup方法　8.2.4　实施测试隔离　8.2.5　避免对不同关注点多次断言　8.2.6　对象比较　8.2.7　避免过度指定　8.3　编写可读的测试　8.3.1　单元测试命名　8.3.2　变量命名　8.3.3　有意义的断言　8.3.4　断言和操作分离　8.3.5　setup和teardown　8.4　小结　第四部分　设计和流程第9章　在组织中引入单元测试　9.1　逐步成为变革的倡导者　9.1.1　准备好面对质疑　9.1.2　说服组织内成员：支持者和反对者　9.1.3　找到可能的切入点　9.2　成功之道　9.2.1　游击式实现(自下而上)　9.2.2　说服高层(自上而下)　9.2.3　引入外援　9.2.4　使进度可见　9.2.5　设定具体目标　9.2.6　应对障碍　9.3　失败原因　9.3.1　缺少驱动力　9.3.2　缺乏政策支持　9.3.3　不好的实现和**印象　9.3.4　缺少团队支持　9.4　影响因素　9.5　质疑和回答　9.5.1　单元测试会给现有流程增加多少时间　9.5.2　单元测试是否会抢了qa饭碗　9.5.3　证明单元测试确实有效的方法　9.5.4　单元测试有用的证据　9.5.5　qa部门还是能找到缺陷的原因　9.5.6　我们有大量没有测试的代码：应该从哪里开始　9.5.7　我们使用多种编程语言：单元测试是否可行　9.5.8　软硬件结合的开发　9.5.9　确保测试中没有缺陷的方法　9.5.10　我的代码已经调试通过了，但还需要测试的原因　9.5.11　驱动开发测试的必要性　9.6　小结　第10章　遗留代码　10.1　从哪里开始增加测试　10.2　决定选择策略　10.2.1　先易后难策略的优缺点　10.2.2　先难后易策略的优缺点　10.3　在重构前编写集成测试　10.4　遗留代码单元测试的重要工具　10.4.1　使用不受限的隔离框架轻松隔离依赖项　10.4.2　使用jmockit测试java遗留代码　10.4.3　重构java代码时使用vise　10.4.4　重构前使用验收测试　10.4.5　阅读michael feathers关于遗留代码的书　10.4.6　使用ndepend调查产品代码　10.4.7　使用resharper浏览和重构产品代码　10.4.8　使用simian和teamcity发现重复代码(和缺陷)　10.5　小结　第11章　设计与可测试性　11.1　为什么在设计时要关心可测试性　11.2　可测试性的设计目标　11.2.1　默认情况下将方法设置为虚拟方法　11.2.2　使用基于接口的设计　11.2.3　默认情况下将类设置为非密封的　11.2.4　避免在包含逻辑的方法内初始化具体类　11.2.5　避免直接调用静态方法　11.2.6　避免在构造函数和静态构造函数中包含逻辑代码　11.2.7　把单例逻辑和单例持有者分开　11.3　可测试性设计的利弊　11.3.1　工作量　11.3.2　复杂度　11.3.3　泄露敏感知识产权　11.3.4　有时无法实现　11.4　可测试性设计的替代方法　11.5　难以测试的设计示例　11.6　小结　11.7　更多资源　附录a　工具和框架　
