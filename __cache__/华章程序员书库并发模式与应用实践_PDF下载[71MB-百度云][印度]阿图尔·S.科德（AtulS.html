华章程序员书库并发模式与应用实践 PDF下载 [印度]阿图尔·S.科德（AtulS 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711162506
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711162506
<p>书名:华章程序员书库并发模式与应用实践</p><p>作者:[印度]阿图尔·S. 科德（Atul S</p><p>页数:207</p><p>定价:¥79.0</p><p>出版社:机械工业出版社</p><p>出版日期:2019-06-01</p><p>ISBN:9787111625063</p><p><h2>本书特色</h2></p>[<p>
本书解释了如何利用并行体系结构的不同特性，使代码更快、更高效。首先介绍基本的并发概念，并探索围绕显式锁定、无锁编程、future模式和actor模式。其次，深入讲解不同的并发模型和并行算法，并将它们应用到不同的场景中，以挖掘应用程序的真正潜力。本书将带读者了解多线程设计模式，如主/从模式，Leader/Followers模式，map-reduce模式，以及监视器模式，还将帮助读者学习使用这些模式的实际编码。<br/>
</p>]<p><h2>内容简介</h2></p>[<p>并发能极大地整合和提高系统的计算性能，特别在以大数据、云计算为特征的信息时代，关于并发的学习和实践具有重大意义。然而，要学好并发，需要遵循一定的章法、范式，这就是并发模式。掌握好并发模式，将使读者的并发设计及开发能力如虎添翼。不过，要掌握好并发模式并能付诸实践，也并非易事。所幸的是，这本书的横空出世为读者学习并发带来了福音。Atul S. Khot作为一名自学成才的很好程序员，有丰富的编程经验和对设计模式的深入研究和深刻洞见。本书通俗易懂，理论与实践紧密结合，书中给出的代码简练、质量高，配图也直观明了、贴近生活。本书对于渴望学习并发模式并希冀能快速实践的读者，将会带来立竿见影的效果。</p>]<p><h2>作者简介</h2></p>[<p>阿图尔·S. 科德（Atul S. Khot）用C和C  编写过软件程序，作为一名Linux迷和擅长使用命令行的程序员，他精通多种编程语言。在大量使用Java编程并涉猎多种语言之后，现在他越来越喜欢Scala、Clojure和Erlang。他经常作为演讲嘉宾参加软件会议，曾担任Dobb博士产品奖评委。他是《Scala Functional Programming Patterns》和《Learning Functional Data Structures and Algorithms》的作者。</p>]<p><h2>目录</h2></p>
    译者序前言作者/评阅者简介第1章　并发简介11.1　并发轻而易举21.1.1　推动并发31.1.2　分时61.1.3　两种并发编程模型71.2　消息传递模型81.2.1　协调和通信101.2.2　流控制121.2.3　分治策略141.2.4　进程状态的概念151.3　共享内存和共享状态模型161.3.1　线程交错—同步的需要181.3.2　竞争条件和海森堡bug201.3.3　正确的内存可见性和happens-before原则211.3.4　共享、阻塞和公平221.3.5　异步与同步执行241.3.6　Java的非阻塞I/O251.4　模式和范式261.4.1　事件驱动的架构281.4.2　响应式编程291.4.3　actor范式311.4.4　消息代理321.4.5　软件事务性内存331.4.6　并行集合341.5　本章小结35第2章　并发模式初探372.1　线程及其上下文382.2　竞争条件402.2.1　监视器模式442.2.2　线程安全性、正确性和不变性452.2.3　双重检查锁定482.2.4　显式锁定522.2.5　生产者/消费者模式602.2.6　比较和交换662.3　本章小结68第3章　更多的线程模式703.1　有界缓冲区723.1.1　策略模式—客户端轮询743.1.2　接管轮询和睡眠的策略753.1.3　使用条件变量的策略773.2　读写锁783.2.1　易读的RW锁803.2.2　公平锁843.3　计数信号量863.4　我们自己的重入锁893.5　倒计时锁存器913.6　循环屏障953.7　future任务973.8　本章小结100第4章　线程池1014.1　线程池1024.1.1　命令设计模式1044.1.2　单词统计1054.1.3　单词统计的另一个版本1074.1.4　阻塞队列1074.1.5　线程中断语义1114.2　fork-join池1114.2.1　Egrep—简易版1124.2.2　为什么要使用递归任务1134.2.3　任务并行性1164.2.4　使用fork-join API实现快速排序1174.2.5　map-reduce技术1244.3　线程的工作窃取算法1254.4　主动对象1284.4.1　隐藏和适应1294.4.2　使用代理1294.5　本章小结132第5章　提升并发性1335.1　无锁堆栈1345.1.1　原子引用1345.1.2　堆栈的实现1355.2　无锁的FIFO队列1375.2.1　流程如何运作1405.2.2　无锁队列1415.2.3　ABA问题1475.3　并发的哈希算法1525.3.1　add(v)方法1535.3.2　contains(v)方法1565.4　大锁的方法1575.5　锁条纹设计模式1595.6　本章小结162第6章　函数式并发模式1636.1　不变性1646.1.1　不可修改的包装器1656.1.2　持久数据结构1676.1.3　递归和不变性1696.2　future模式1706.2.1　apply方法1716.2.2　future—线程映射1736.2.3　future模式是异步的1746.2.4　糟糕的阻塞1776.2.5　函数组合1796.3　本章小结182第7章　actor模式1837.1　消息驱动的并发1837.1.1　什么是actor1857.1.2　状态封装1897.1.3　并行性在哪里1907.1.4　未处理的消息1927.1.5　become模式1937.1.6　让它崩溃并恢复1977.1.7　actor通信—ask模式1997.1.8　actor通信—tell模式2047.1.9　pipeTo模式2057.2　本章小结207
