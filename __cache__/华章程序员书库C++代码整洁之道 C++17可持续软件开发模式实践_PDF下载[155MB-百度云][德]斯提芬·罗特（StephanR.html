华章程序员书库C++代码整洁之道:C++17可持续软件开发模式实践 PDF下载 [德]斯提芬·罗特（StephanR 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711162190
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711162190
<p>书名:华章程序员书库C++代码整洁之道:C++17可持续软件开发模式实践</p><p>作者:[德] 斯提芬·罗特（Stephan R</p><p>页数:276</p><p>定价:¥89.0</p><p>出版社:机械工业出版社</p><p>出版日期:2019-04-01</p><p>ISBN:9787111621904</p><p><h2>本书特色</h2></p>[<p>
使用现代C  编写可维护、可扩展和持久的软件。对于每一个对好的C  代码感兴趣的开发人员、软件架构师或团队领导来说，这本书都是必须的，因此也想节省开发成本。如果你想自学编写整洁C  代码，本书正是你所需要的。编写它是为了帮助所有级别的C  开发人员，并通过示例展示如何编写可理解的、灵活的、可维护的和高效的C  代码。即使是经验丰富的C  开发人员，在本书中也会发现一些有用的信息和数据。
                                        </p>]<p><h2>内容简介</h2></p>[<p>使用现代C++编写可维护、可扩展和持久的软件。对于每一个对好的C++代码感兴趣的开发人员、软件架构师或团队领导来说，这本书都是必须的，因此也想节省开发成本。如果你想自学编写整洁C++代码，本书正是你所需要的。编写它是为了帮助所有级别的C++开发人员，并通过示例展示如何编写可理解的、灵活的、可维护的和高效的C++代码。即使是经验丰富的C++开发人员，在本书中也会发现一些有用的信息和数据。</p>]<p><h2>作者简介</h2></p>[<p>斯蒂芬·罗斯（Stephan Roth）是德国汉堡一家咨询公司的系统和软件工程导师、顾问和培训师。在此之前，他在无线电侦察和通信情报系统领域做了多年的软件开发工程师、软件架构师和系统工程师。Stephan还是一位的演说家及作家，目前已出版多本专业书籍。此外，他还是一个坚定的软件工艺运动支持者，关注于简洁代码开发的规范制定及实践。</p>]<p><h2>目录</h2></p>
    译者序关于作者关于技术审校致谢第1章　简介11.1　软件熵21.2　整洁的代码41.3　为什么使用C  41.4　C  11—新时代的开始51.5　适合本书的读者51.6　本书使用的约定61.6.1　扩展阅读61.6.2　说明、提示和警告61.6.3　示例代码71.6.4　编码风格71.7　相关网站和代码库71.8　UML图8第2章　构建安全体系92.1　测试的必要性92.2　测试入门112.3　单元测试132.4　关于QA152.5　良好的单元测试原则162.5.1　单元测试的代码的质量162.5.2　单元测试的命名162.5.3　单元测试的独立性172.5.4　一个测试一个断言182.5.5　单元测试环境的独立初始化192.5.6　不对getters和setters做单元测试192.5.7　不对第三方代码做单元测试202.5.8　不对外部系统做单元测试202.5.9　如何处理数据库的访问202.5.10　不要混淆测试代码和产品代码212.5.11　测试必须快速执行232.5.12　测试替身24第3章　原则273.1　什么是原则273.2　保持简单和直接原则（KISS）283.3　不需要原则（YAGNI）293.4　避免复制原则（DRY）293.5　信息隐藏原则303.6　高内聚原则333.7　松耦合原则353.8　小心优化原则383.9　*少惊讶原则（PLA）393.10　童子军原则39第4章　C  代码整洁的基本规范414.1　良好的命名424.1.1　名称应该自解释434.1.2　使用域中的名称454.1.3　选择适当抽象层次的名称454.1.4　避免冗余的名称464.1.5　避免晦涩难懂的缩写474.1.6　避免匈牙利命名和命名前缀474.1.7　避免相同的名称用于不同的目的484.2　注释494.2.1　让写代码像讲故事一样494.2.2　不要为易懂的代码写注释504.2.3　不要通过注释禁用代码504.2.4　不要写块注释514.2.5　特殊情况的注释是有用的534.3　函数564.3.1　只做一件事情594.3.2　让函数尽可能小594.3.3　函数命名614.3.4　使用容易理解的名称614.3.5　函数的参数和返回值624.4　C  工程中的C风格代码724.4.1　使用C  的string和stream替代C风格的char*734.4.2　避免使用printf()、sprintf()和gets()等744.4.3　使用标准库的容器而不是C风格的数组774.4.4　用C  类型转换代替C风格的强制转换804.4.5　避免使用宏81第5章　现代C  的高级概念835.1　资源管理845.1.1　资源申请即初始化855.1.2　智能指针865.1.3　避免显式的new和delete925.1.4　管理特有资源925.2　Move语义945.2.1　什么是Move语义945.2.2　左值和右值的关系955.2.3　右值引用965.2.4　不要滥用Move975.2.5　零原则985.3　编译器是你的搭档1025.3.1　自动类型推导1025.3.2　编译时计算1055.3.3　模板变量1075.4　不允许未定义的行为1085.5　Type-Rich编程1105.6　了解你使用的库1165.6.1　熟练使用1165.6.2　熟练使用Boost1215.6.3　应该了解的一些库1215.7　恰当的异常和错误处理机制1225.7.1　防患于未然1235.7.2　异常即异常—字面上的意思1265.7.3　如果不能恢复则尽快退出1285.7.4　用户自定义异常1285.7.5　值类型抛出，常量引用类型捕获1305.7.6　注意catch的正确顺序130第6章　面向对象1316.1　面向对象思想1326.2　抽象—解决复杂问题的关键因素1336.3　类的设计原则1346.3.1　让类尽可能小1346.3.2　单一职责原则（SRP）1356.3.3　开闭原则（OCP）1356.3.4　里氏替换原则(LSP)1366.3.5　接口隔离原则（ISP）1466.3.6　无环依赖原则1486.3.7　依赖倒置原则（DIP）1516.3.8　不要和陌生人说话（迪米特法则）1566.3.9　避免“贫血类”1606.3.10　只说不问1606.3.11　避免类的静态成员162第7章　函数式编程1647.1　什么是函数式编程1657.1.1　什么是函数1667.2.2　pure函数和impure函数1677.2　现代C  中的函数式编程1687.2.1　C  模板函数编程1687.2.2　仿函数1707.2.3　绑定和函数包装1767.2.4　Lambda表达式1787.2.5　通用Lambda表达式（C  14）1807.3　高阶函数1817.4　整洁的函数式编程代码186第8章　测试驱动开发1888.1　普通的旧单元测试的缺点1898.2　测试驱动开发作为颠覆者1908.2.1　TDD的流程1908.2.2　TDD的一个小例子：Code Kata1938.3　TDD的优势2108.4　什么时候不应该使用TDD212第9章　设计模式和习惯用法2139.1　设计原则与设计模式2149.2　常见的设计模式及应用场景2149.2.1　依赖注入模式2159.2.2　Adapter模式2269.2.3　Strategy模式2279.2.4　Command模式2319.2.5　Command处理器模式2359.2.6　Composite模式2389.2.7　Observer模式2419.2.8　Factory模式2459.2.9　Facade模式2489.2.10　Money Class模式2499.2.11　特例模式2529.3　什么是习惯用法255附录A　UML简要指南266参考文献275
